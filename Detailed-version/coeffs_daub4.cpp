#include "global.h"
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

using std::ifstream;
using std::ofstream;
using std::string;
using namespace std;
struct Daub4
{
	static float phi(float x);
	static float int_phi(float x);
	static float psi(float x);
	static float int_psi(float x);
	static float div_phi(float x);
	static float div_psi(float x);
	static float phi_smooth(int d,float x);
	static float int_phi_smooth(int d,float x);
	static float psi_smooth(int d,float x);
	static float int_psi_smooth(int d,float x);
};

static float interpolate(float table[193], float x)
{
	const float xp = (x + 1) * 64;
	const int L = int(xp);
	const float a = xp - L;
	return (1-a)*table[L] + a*table[L+1];
}
static float interpolate2(float table[769], float x)
{
	const float xp = (x + 1) * 256;
	const int L = int(xp);
	const float a = xp - L;
	return (1-a)*table[L] + a*table[L+1];
}

static float phi_t[193] = {0., 0.13868562803742573, 0.2030498520059889, 0.2402105540404202, \
			0.29728561627545036, 0.3145319581092828, 0.3516926601437141, \
			0.39614252391167837, 0.43525635094610965, 0.43792436931287615, \
			0.4605067478802415, 0.4903782881811398, 0.5149137917485052, \
			0.5501213687829365, 0.5799929090838348, 0.6079113243847332, \
			0.6372595264191645, 0.6292554713188651, 0.6411657764191645, \
			0.660365243252997, 0.6742286733532963, 0.6987641769206617, \
			0.7179636437544941, 0.7352099855883265, 0.7538861141556918, \
			0.7823278677230572, 0.8054335845568896, 0.8265861763907221, \
			0.8491685549580874, 0.868891360058387, 0.8900439518922193, \
			0.9117198819925187, 0.9330127018922193, 0.9171961467919199, \
			0.9212939518922193, 0.9326809187260516, 0.9387318488263511, \
			0.9554548523937165, 0.966841819227549, 0.9762756610613814, \
			0.9871392896287468, 1.007768543196112, 1.0230617600299445, \
			1.036401851863777, 1.0511717304311423, 1.0630820355314419, \
			1.076422127365274, 1.0902855574655734, 1.103765877365274, \
			1.1272547043997054, 1.1454074947006037, 1.161607160001502, \
			1.1792366120359334, 1.1940064906032988, 1.210206155904197, \
			1.2269291594715623, 1.243269052838329, 1.2569922548727601, \
			1.2721452436407246, 1.2878215706751557, 1.3031147875089881, \
			1.3191742247440184, 1.3348505517784497, 1.3503866507470128, \
			1.3660254037844386, 1.1042791477095872, 0.9911756997724608, \
			0.9324792957035982, 0.8339541712335379, 0.815086487565873, \
			0.7563900834970104, 0.6831153559610819, 0.6205127018922193, \
			0.6308016651586863, 0.6012619080239556, 0.557143827422159, \
			0.5236978202874282, 0.4689076662185656, 0.4247895856167689, \
			0.38457775501497227, 0.34150635094610965, 0.37313946114670854, \
			0.36494385094610965, 0.3421699172784448, 0.3300680570778459, \
			0.2966220499431152, 0.27384811627545036, 0.2549804326077856, \
			0.23325317547305482, 0.19199466833832407, 0.16140823467065926, \
			0.13472805100299445, 0.1051882938682637, 0.08136768366766481, \
			0.0546875, 0.02696063979940111, 0., 0.04725811020059889, \
			0.0546875, 0.047538566332335185, 0.051061706131736294, \
			0.033240698997005554, 0.026091765329340738, 0.022849081661675923, \
			0.016746824526945175, -0.008886682607785579, \
			-0.023848116275450387, -0.034903299943115196, \
			-0.04881805707784595, -0.05701366727844484, -0.06806885094610965, \
			-0.08017071114670854, -0.09150635094610965, -0.12285900501497227, \
			-0.14353958561676894, -0.1603139162185656, -0.17994782028742817, \
			-0.1938625774221589, -0.21063690802395563, -0.22845791515868635, \
			-0.2455127018922193, -0.2573341059610819, -0.2720150834970104, \
			-0.287742737565873, -0.3027041712335379, -0.3191980457035982, \
			-0.33492569977246084, -0.35037289770958713, -0.3660254037844386, \
			-0.2429647757470128, -0.1942255517784497, -0.17268984974401835, \
			-0.13123978750898824, -0.1296184456751558, -0.10808274364072445, \
			-0.07925787987276023, -0.055769052838329, -0.06872603447156245, \
			-0.06176865590419711, -0.047522115603298776, -0.03861161203593344, \
			-0.019029035001502104, -0.004782494700603768, \
			0.007510920600294568, 0.021234122634725905, \
			-0.0023949324655735404, -0.006109627365274095, \
			-0.0025351605314417602, -0.004296730431142315, \
			0.0046137731362231316, 0.008188239970055494, 0.009809581803887912, \
			0.012860710371253303, 0.02567746393861864, 0.033158180772451085, \
			0.038685772606283475, 0.045643151173648866, 0.04974095627394831, \
			0.0552685481077807, 0.06131947820808015, 0.0669872981077807, \
			0.035545743007481256, 0.0240185481077807, 0.019780514941613092, \
			0.010206445041912537, 0.011304448609277928, 0.007066415443110319, \
			0.0008752572769427647, -0.0038861141556919, 0.001118139411673491, \
			0.0007863562455058815, -0.0014985519206616865, \
			-0.002353673353296337, -0.006068368252996892, \
			-0.008353276419164501, -0.010114846318865056, \
			-0.012259526419164501, -0.004395699384733165, \
			-0.001867909083834829, -0.001293243782936493, \
			0.0007112082514947882, -0.00014391318113984863, \
			0.00043075211975848737, 0.0015287556871238783, \
			0.002243649053890351, 0.00034185108832165967, \
			-0.00013016014371408646, -0.0000788331092828054, \
			-0.00041061627545038726, 0.00002382095957979835, \
			0.00007514799401110717, -0.000013753037425748293, 0.};

static float int_phi_t[193] = {0., 0.0013478692971751866, 0.003946835229977561, \
				0.00733896464717833, 0.011557135669785477, 0.016266117964629404, \
				0.02148997998674535, 0.027351424554192514, 0.03384164200099815, \
				0.040592523872984676, 0.04763049916807031, 0.05507827070431426, \
				0.06292702881574377, 0.07126659819941007, 0.08009052973222339, \
				0.08936594529317576, 0.09909520542515012, 0.10891901133994167, \
				0.11886315952990945, 0.1290503528131126, 0.13947178152357845, \
				0.15021727035835816, 0.16128037019436198, 0.17262820291058192, \
				0.18426312904990097, 0.19628378297534313, 0.2086830830582594, \
				0.22142815117764175, 0.23452134787637324, 0.24793860469941864, \
				0.2616816496841017, 0.2757592924963951, 0.29017090063073975, \
				0.30455481475604784, 0.31893700084403204, 0.3334401617127517, \
				0.34805548769623407, 0.36287280349153017, 0.3778856599755505, \
				0.39306117902728693, 0.4084017211896225, 0.42400592082558114, \
				0.4398666963065138, 0.4559511695114127, 0.47226170098316067, \
				0.4887742222667225, 0.505490461399422, 0.522419228047232, \
				0.539559889704593, 0.5570087201916464, 0.5747588073590967, \
				0.5927772730859361, 0.6110664779150474, 0.6296023533913957, \
				0.6483866275523045, 0.6674281100637464, 0.6867261684201627, \
				0.7062543736236346, 0.7260146231908401, 0.7460157267877519, \
				0.7662570519088107, 0.7867450476771062, 0.8074792510664333, \
				0.8284573015339085, 0.8496793685588859, 0.8684498472111676, \
				0.8849622732171945, 0.9001325128794249, 0.9138948099558425, \
				0.9269196251127866, 0.9391588214401863, 0.9503669933019239, \
				0.9605617600299445, 0.9704793385326032, 0.9800668708140639, \
				0.9890789512382077, 0.9975331991369806, 1.0052499651162798, \
				1.0122421474222851, 1.0185755022970122, 1.0242453086546952, \
				1.029970164071744, 1.0356984755634404, 1.041184837493666, \
				1.046446869194366, 1.0513049212714385, 1.0557718919710628, \
				1.0599135375352549, 1.0637251368782483, 1.067009421273996, \
				1.0697805539797953, 1.0721042912376624, 1.0739759119618313, \
				1.0754435530623723, 1.076503758464638, 1.0771389088366832, \
				1.0773502691896257, 1.0778611581856414, 1.0786196438813047, \
				1.0793803206404973, 1.0801608077951645, 1.0807814559512041, \
				1.0812551633547953, 1.0816476862479543, 1.081954303544915, \
				1.0819777465196299, 1.081732178429396, 1.0812833555162302, \
				1.080626556694366, 1.0798099188738741, 1.0788299859801072, \
				1.0776691386811192, 1.0763286419880287, 1.0746159482605537, \
				1.0725448817972851, 1.0701811988402383, 1.0675201783036472, \
				1.0646099570975827, 1.061447079147397, 1.058013925121145, \
				1.0543117600299445, 1.0503934418696321, 1.046255175606853, \
				1.0418793419096615, 1.0372672057891759, 1.0324058689992166, \
				1.0272962575921945, 1.0219430926538757, 1.0163460352255527, \
				1.011852687276096, 1.0083662953372665, 1.0054289262578353, \
				1.0030734581588105, 1.0009646607070226, 0.9991266023575067, \
				0.9976819859283221, 0.996622001753496, 0.9955785413788505, \
				0.9945780338023045, 0.9937431818419166, 0.9930651758317142, \
				0.9926338404687486, 0.99244272662993, 0.9924589561942506, \
				0.992684889704593, 0.9927612283727527, 0.9927137686910887, \
				0.9926652134776601, 0.9926067530664939, 0.9926282121546418, \
				0.9927231416190139, 0.992858663338602, 0.9930371378562892, \
				0.9933571995350994, 0.9938117667463838, 0.9943679613691343, \
				0.9950281439462341, 0.9957682460226476, 0.9965899956356987, \
				0.9975022024513603, 0.9985042339640731, 0.9992344308427492, \
				0.9997187590591017, 1.0000799214311895, 1.00030910829304, \
				1.0004961443417042, 1.0006345804540926, 1.0006915385091972, \
				1.000669379049901, 1.0006667364392277, 1.0006765290485284, \
				1.0006658787567957, 1.0006371461069117, 1.0005662626438419, \
				1.0004549564049094, 1.0003120370560874, 1.0001368720918167, \
				1.0000257353322382, 0.9999717146280567, 0.9999419318582643, \
				0.9999387475657437, 0.9999380932954601, 0.9999416970847369, \
				0.9999583685995472, 0.9999874753343315, 1.0000025882911716, \
				1.0000056049867454, 1.000005335087025, 1.000001146086452, \
				0.9999994871081157, 0.9999998951258109, 1.0000000095966541, 1.};

static float psi_t[193] = {0, 0.03716070203443130, 0.05440704386826371, 0.06436422396856315, \
							0.07965744080239556, 0.08427858416916204, 0.09423576426946149, \
							0.1061460693697609, 0.1166265877365274, 0.1173414811032939, \
							0.1233924112035933, 0.1313964663038928, 0.1379707346706593, \
							0.1474045765044917, 0.1554086316047911, 0.1628893484386235, \
							0.1707531754730548, 0.1686084953727554, 0.1717998520059889, \
							0.1769443336392224, 0.1806590285389230, 0.1872332969056895, \
							0.1923777785389230, 0.1969989219056895, 0.2020031754730548, \
							0.2096241203727554, 0.2158152785389230, 0.2214830984386235, \
							0.2275340285389230, 0.2328187382380246, 0.2384865581377252, \
							0.2442946061032939, 0.2500000000000000, 0.2457619668338324, \
							0.2468599704011978, 0.2499110989685632, 0.2515324408023956, \
							0.2560133561032939, 0.2590644846706593, 0.2615922749715576, \
							0.2645031754730548, 0.2700307673068872, 0.2741285724071867, \
							0.2777030392410191, 0.2816606162754504, 0.2848519729086839, \
							0.2884264397425163, 0.2921411346422169, 0.2957531754730548, \
							0.3020469877080850, 0.3069110132095822, 0.3112517004446124, \
							0.3159754978802415, 0.3199330749146728, 0.3242737621497030, \
							0.3287546774506013, 0.3331329386826371, 0.3368100595853321, \
							0.3408702906886260, 0.3450707498577880, 0.3491685549580875, \
							0.3534716681961121, 0.3576721273652742, 0.3618350125374306, \
							0.3660254037844386, 0.03843380997305973, -0.1113583287664621, \
							-0.1960713501706544, -0.3284255919760444, -0.3654973929790388, \
							-0.4502104143832311, -0.5523613327215552, -0.6417468245269452, \
							-0.6439428316616759, -0.6937800591976044, -0.7610551836676648, \
							-0.8155648816047911, -0.8956054326077856, -0.9628805570778460, \
							-1.025483211146709, -1.091506350946110, -1.068171505014972, \
							-1.092477879485033, -1.134222150889225, -1.163200995760483, \
							-1.217710693697609, -1.259454965101802, -1.296526766104796, \
							-1.337019052838329, -1.400873691577851, -1.451962903784439, \
							-1.498379645589829, -1.548216873125757, -1.591213129200609, \
							-1.637629871005999, -1.685298597482048, -1.732050807568877, \
							-1.095454847482048, -0.8251298710059987, -0.6888693792006087, \
							-0.4544668731257572, -0.4163483955898287, -0.2800879037844386, \
							-0.1079049415778509, 0.03798094716167101, 0.004254483895203978, \
							0.06867003489819843, 0.1690080563023907, 0.2430490042395170, \
							0.3696840991107751, 0.4700221205149674, 0.5607347449850277, \
							0.6584936490538903, 0.5721730388532914, 0.5839944429221540, \
							0.6317383173922144, 0.6531851183952089, 0.7272260663323352, \
							0.7749699408023956, 0.8130884183383241, 0.8582531754730548, \
							0.9515449172784448, 1.018539585616769, 1.075908857020961, \
							1.140324408023956, 1.190647399829346, 1.248016671233538, \
							1.307965059973060, 1.366025403784439, 0.9067568875374306, \
							0.7248596273652742, 0.6444872931961121, 0.4897935549580875, \
							0.4837426248577880, 0.4033702906886260, 0.2957944345853321, \
							0.2081329386826371, 0.2564890524506013, 0.2305237621497030, \
							0.1773549499146728, 0.1441004978802415, 0.07101732544461244, \
							0.01784851320958225, -0.02803113729191498, -0.07924682452694517, \
							0.008938009642216874, 0.02280143974251632, 0.009461347908683911, \
							0.01603561627545039, -0.01721883575898091, -0.03055892759281332, \
							-0.03660985769311276, -0.04799682452694517, -0.09582960002844240, \
							-0.1237480153293407, -0.1443772688967061, -0.1703425591976044, \
							-0.1856357760314368, -0.2062650295988022, -0.2288474081661676, \
							-0.2500000000000000, -0.1326585188967061, -0.08963844186227480, \
							-0.07382188676197536, -0.03809097146107702, -0.04218877656137647, \
							-0.02637222146107702, -0.003266504627244614, 0.01450317547305483, \
							-0.004172953094310541, -0.002934721461077023, 0.005592671905689459, \
							0.008784028538922977, 0.02264745863922242, 0.03117485200598890, \
							0.03774912037275539, 0.04575317547305483, 0.01640497343862353, \
							0.006971131604791123, 0.004826451504491678, -0.002654265329340731, \
							0.0005370913038927875, -0.001607588796406658, -0.005705393896706103, \
							-0.008373412263472585, -0.001275805630239066, 0.0004857642694614885, \
							0.0002942091691620433, 0.001532440802395562, -0.00008890103143684709, \
							-0.0002804561317362923, 0.00005132703443129905, 0};

static float int_psi_t[193] = {0, 0.0007223209793615925, 0.002115102625062384, \
								0.003932939300983987, 0.006193450339071883, 0.008716986345223653, \
								0.01151644556561881, 0.01465758424227333, 0.01813568128942124, \
								0.02175346798101463, 0.02552510757435141, 0.02951635631144754, \
								0.03372249310653707, 0.03819165486969047, 0.04292038552626017, \
								0.04789106574430067, 0.05310496053493037, 0.05836952225786734, \
								0.06369857521170189, 0.06915787563844998, 0.07474270245234565, \
								0.08050119256345939, 0.08642988989714361, 0.09251117512145283, \
								0.09874631324750544, 0.1051881622711379, 0.1118329271589950, \
								0.1186629885791313, 0.1256796115426652, 0.1328698978034172, \
								0.1402347734137980, 0.1477789594595737, 0.1555021169820366, \
								0.1632104333297864, 0.1709178236251254, 0.1786900441100696, \
								0.1865223736988529, 0.1944629493015460, 0.2025083148435012, \
								0.2106408509927730, 0.2188618227604798, 0.2272240881424580, \
								0.2357238521053526, 0.2443434953172179, 0.2530842827891725, \
								0.2619333162750368, 0.2708915218272215, 0.2799636205314927, \
								0.2891492734291427, 0.2985000735048897, 0.3080123165490904, \
								0.3176683832297994, 0.3274695385581349, 0.3374028842879176, \
								0.3474693464715582, 0.3576736461948227, 0.3680154444990035, \
								0.3784805781268027, 0.3890700639543430, 0.3997886230673904, \
								0.4106359165072374, 0.4216154003485315, 0.4327268264562771, \
								0.4439689298193558, 0.4553418012614795, 0.4603964839118197, \
								0.4595959920417943, 0.4551313570445234, 0.4468452699436159, \
								0.4363416770398143, 0.4235054201699135, 0.4077494142415360, \
								0.3891158100678677, 0.3693658629260420, 0.3483731203765005, \
								0.3255504973268654, 0.3009401445903228, 0.2741122860508861, \
								0.2450977782453876, 0.2140539301502185, 0.1809694474890252, \
								0.1475634347257548, 0.1137124657130770, 0.07882945535861395, \
								0.04295655447555184, 0.005663986947903877, -0.03301739068749735, \
								-0.07293026945426086, -0.1140859436287402, -0.1569563401401083, \
								-0.2015075761593045, -0.2475823427099378, -0.2951919340683619, \
								-0.3442211920713718, -0.3946783847030930, -0.4466056627767118, \
								-0.5000000000000000, -0.5415738619628715, -0.5722812507135736, \
								-0.5966357415223782, -0.6143132742649714, -0.6286180153629788, \
								-0.6393127363406955, -0.6451880283494750, -0.6463307230379265, \
								-0.6463690469519891, -0.6450425051458360, -0.6411416887708205, \
								-0.6347534294755518, -0.6249923785356973, -0.6119221011297437, \
								-0.5958666573820048, -0.5768027808223586, -0.5582718663481352, \
								-0.5400196532453876, -0.5208367326654694, -0.5008099362569895, \
								-0.4790539152956154, -0.4556322349598338, -0.4308689553739587, \
								-0.4047408100678677, -0.3762756186686193, -0.3455431805865802, \
								-0.3128675559460643, -0.2782254782769493, -0.2418541760549400, \
								-0.2037366170417943, -0.1637859695889030, -0.1220084679281462, \
								-0.08846966224123079, -0.06244687853961043, -0.04052205724957317, \
								-0.02294060400723741, -0.007200325541348758, 0.006519128753990357, \
								0.01730189257632235, 0.02521372216766318, 0.03300221643538563, \
								0.04047010665344178, 0.04670152651937405, 0.05176223227519841, \
								0.05498176325457565, 0.05640825636757625, 0.05628711725031862, \
								0.05460072657085727, 0.05403092699454898, 0.05438517088111184, \
								0.05474759192808824, 0.05518394637749415, 0.05502377356299038, \
								0.05431521039464742, 0.05330366250858364, 0.05197151057285357, \
								0.04958253767910203, 0.04618960182316549, 0.04203810864116233, \
								0.03711043880114706, 0.03158624169722210, 0.02545261908320795, \
								0.01864381471708863, 0.01116454968463011, 0.005714285983134676, \
								0.002099210961201996, -0.0005965416836255162, -0.002307215709331892, \
								-0.003703271782256331, -0.004736572992328350, -0.005161713703429558, \
								-0.004996313247505440, -0.004976588532911164, -0.005049681563810277, \
								-0.004970186704084390, -0.004755723285678987, -0.004226641914491648, \
								-0.003395840836701888, -0.002329076294325675, -0.001021627201597041, \
								-0.0001920911349256700, 0.0002111248904065015, 0.0004334265105178628, \
								0.0004571943934629296, 0.0004620779333441230, 0.0004351788839819272, \
								0.0003107410033603736, 0.00009348537724543076, \
								-0.00001931926831499626, -0.00004183619061881258, \
								-0.00003982163168198657, -8.554505738549842e-6, 
								 3.828277141013405e-6, 
								 7.827916042822509e-7, -7.163040325911985e-8, 0};

// static float phi_t[193] = {
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,\

// 							1. , 1.  ,\
// 							1. , 1., 1., \
// 							1. , 1. , 1. ,\
// 							1. , 1.,  1., \
// 							1. , 1. , 1. ,\

// 							1. , 1. , 1.,\
//   							1. , 1. , 1.,\
// 							1. , 1. , 1.,\
// 							1. , 1. , 1. ,\
// 							1. , 1. , 1. ,\


// 							1. , 1. , 1.,\
//   							1. , 1. , 1.,\
// 							1. , 1. , 1.,\
// 							1. , 1. , 1. ,\
// 							1. , 1. , 1. ,\


// 							1. , 1. , 1.,\
//   							1. , 1. , 1.,\
// 							1. , 1. , 1.,\
// 							1. , 1. , 1. ,\
// 							1. , 1. , 1. ,\
// 							1. , 1. , 1. ,\
// 							1. , 1. ,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0						

// 							};



// static float psi_t[193] = {
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,\

// 							1. , 1.  ,\
// 							1. , 1.,  1. ,\ 
// 							1. , 1. , 1. ,\
// 							1. , 1.,  1.,  \
// 							1. , 1. , 1. ,\

// 							1. , 1. , 1.,\
//   							1. , 1. , 1.,\
// 							1. , 1. , 1.,\
// 							1. , 1. , 1. ,\
// 							1. , 1. , 1. ,\

// 							1.,  1. , 1.,\

// 							-1. ,-1., -1.,\
//  							-1., -1., -1., \
// 							-1. ,-1. , -1.,\
// 							-1. , -1., -1., \

// 							-1., -1. ,-1. ,\
// 							-1., -1. ,-1. ,\
// 							-1. ,-1., -1.,\
// 							-1. ,-1., -1. ,\
// 							-1. ,-1., -1., \

// 							-1., -1., -1. ,
// 							-1. ,-1.,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\
// 							0,0,0,\

// 							0,0,0,\
// 							0						

// 							};



// static float int_psi_t[193] = {
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \

// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \

// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \

// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \

// 								0, 0, 0, \
// 								0, 0, \
							
// 								0.015625,0.03125,0.046875,\
// 								0.0625,0.078125,0.09375,\
// 								0.109375,0.125,0.140625,\
// 								0.15625,0.171875,0.1875,\
// 								0.203125,0.21875,0.234375,\
// 								0.25,0.265625,0.28125,\
// 								0.296875,0.3125,0.328125,\
// 								0.34375,0.359375,0.375,\
// 								0.390625,0.40625,0.421875,\
// 								0.4375,0.453125,0.46875,\
// 								0.484375,0.5,
// 								0.484375,0.46875,0.453125,\
// 								0.4375,0.421875,0.40625,\
// 								0.390625,0.375,0.359375,\
// 								0.34375,0.328125,0.3125,\
// 								0.296875,0.28125,0.265625,\
// 								0.25,0.234375,0.21875,\
// 								0.203125,0.1875,0.171875,\
// 								0.15625,0.140625,0.125,\
// 								0.109375,0.09375,0.078125,\
// 								0.0625,0.046875,0.03125,\
// 								0.015625,0.0,\
															

// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \

// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \

// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \

// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \
// 								0, 0, 0, \

// 								0, 0, 0, \
// 								0
// 								};

// static float int_phi_t[193] = {
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \

// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
// 				0., 0., 0., \
				
// 				0., 0., 0., \
// 				0., 0.,  \

// 				0.015625,0.03125,0.046875,\
// 				0.0625,0.078125,0.09375,\
// 				0.109375,0.125,0.140625,\
// 				0.15625,0.171875,0.1875,\
// 				0.203125,0.21875,0.234375,\
// 				0.25,0.265625,0.28125,\
// 				0.296875,0.3125,0.328125,\
// 				0.34375,0.359375,0.375,\
// 				0.390625,0.40625,0.421875,\
// 				0.4375,0.453125,0.46875,\
// 				0.484375,0.5,0.515625,\
// 				0.53125,0.546875,0.5625,\
// 				0.578125,0.59375,0.609375,\
// 				0.625,0.640625,0.65625,\
// 				0.671875,0.6875,0.703125,\
// 				0.71875,0.734375,0.75,\
// 				0.765625,0.78125,0.796875,\
// 				0.8125,0.828125,0.84375,\
// 				0.859375,0.875,0.890625,\
// 				0.90625,0.921875,0.9375,\
// 				0.953125,0.96875,0.984375,\
// 				1.0,\


// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\

// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\

// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\

// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\
// 				1,1,1,\

// 				1,1,1,1\
// };

static float phi_s0[769];
static float phi_s1[769];
static float phi_s2[769];
static float phi_s3[769];
static float phi_s4[769];
static float phi_s5[769];
static float phi_s6[769];
static float phi_s7[769];
static float phi_s8[769];
static float phi_s9[769];

static float psi_s0[769];
static float psi_s1[769];
static float psi_s2[769];
static float psi_s3[769];
static float psi_s4[769];
static float psi_s5[769];
static float psi_s6[769];
static float psi_s7[769];
static float psi_s8[769];
static float psi_s9[769];

static float int_psi_s0[769];
static float int_psi_s1[769];
static float int_psi_s2[769];
static float int_psi_s3[769];
static float int_psi_s4[769];
static float int_psi_s5[769];
static float int_psi_s6[769];
static float int_psi_s7[769];
static float int_psi_s8[769];
static float int_psi_s9[769];

static float int_phi_s0[769];
static float int_phi_s1[769];
static float int_phi_s2[769];
static float int_phi_s3[769];
static float int_phi_s4[769];
static float int_phi_s5[769];
static float int_phi_s6[769];
static float int_phi_s7[769];
static float int_phi_s8[769];
static float int_phi_s9[769];
float Daub4::phi(float x)
{
	return interpolate(phi_t, x);
}

float Daub4::int_phi(float x)
{
	return interpolate(int_phi_t, x);
}

float Daub4::psi(float x)
{
	return interpolate(psi_t, x);
}

float Daub4::int_psi(float x)
{
	return interpolate(int_psi_t, x);
}
float Daub4::phi_smooth(int d,float x)
{
	switch (d)
	{
	case 0:
		return interpolate2(phi_s0, x);
		break;
	case 1:
		return interpolate2(phi_s1, x);
		break;
	case 2:
		return interpolate2(phi_s2, x);
		break;
	case 3:
		return interpolate2(phi_s3, x);
		break;
	case 4:
		return interpolate2(phi_s4, x);
		break;
	case 5:
		return interpolate2(phi_s5, x);
		break;
	case 6:
		return interpolate2(phi_s6, x);
		break;
	case 7:
		return interpolate2(phi_s7, x);
		break;
	case 8:
		return interpolate2(phi_s8, x);
		break;
	case 9:
		return interpolate2(phi_s9, x);
		break;		
	default:
		cout<<"interpolate is error"<<endl;
		return 0;
		break;
	}
}

float Daub4::int_phi_smooth(int d,float x)
{
	switch (d)
	{
	case 0:
		return interpolate2(int_phi_s0, x);
		break;
	case 1:
		return interpolate2(int_phi_s1, x);
		break;
	case 2:
		return interpolate2(int_phi_s2, x);
		break;
	case 3:
		return interpolate2(int_phi_s3, x);
		break;
	case 4:
		return interpolate2(int_phi_s4, x);
		break;
	case 5:
		return interpolate2(int_phi_s5, x);
		break;
	case 6:
		return interpolate2(int_phi_s6, x);
		break;
	case 7:
		return interpolate2(int_phi_s7, x);
		break;
	case 8:
		return interpolate2(int_phi_s8, x);
		break;
	case 9:
		return interpolate2(int_phi_s9, x);
		break;		
	default:
		cout<<"interpolate is error"<<endl;
		return 0;
		break;
	}
	
}

float Daub4::psi_smooth(int d,float x)
{
	switch (d)
	{
	case 0:
		return interpolate2(psi_s0, x);
		break;
	case 1:
		return interpolate2(psi_s1, x);
		break;
	case 2:
		return interpolate2(psi_s2, x);
		break;
	case 3:
		return interpolate2(psi_s3, x);
		break;
	case 4:
		return interpolate2(psi_s4, x);
		break;
	case 5:
		return interpolate2(psi_s5, x);
		break;
	case 6:
		return interpolate2(psi_s6, x);
		break;
	case 7:
		return interpolate2(psi_s7, x);
		break;
	case 8:
		return interpolate2(psi_s8, x);
		break;
	case 9:
		return interpolate2(psi_s9, x);
		break;		
	default:
		cout<<"interpolate is error"<<endl;
		return 0;
		break;
	}
}

float Daub4::int_psi_smooth(int d,float x)
{
	switch (d)
	{
	case 0:
		return interpolate2(int_psi_s0, x);
		break;
	case 1:
		return interpolate2(int_psi_s1, x);
		break;
	case 2:
		return interpolate2(int_psi_s2, x);
		break;
	case 3:
		return interpolate2(int_psi_s3, x);
		break;
	case 4:
		return interpolate2(int_psi_s4, x);
		break;
	case 5:
		return interpolate2(int_psi_s5, x);
		break;
	case 6:
		return interpolate2(int_psi_s6, x);
		break;
	case 7:
		return interpolate2(int_psi_s7, x);
		break;
	case 8:
		return interpolate2(int_psi_s8, x);
		break;
	case 9:
		return interpolate2(int_psi_s9, x);
		break;		
	default:
		cout<<"interpolate is error"<<endl;
		return 0;
		break;
	}
}

float Daub4::div_psi(float x)
{
	return interpolate(int_psi_t, x);
}

float Daub4::div_phi(float x)
{
	return interpolate(int_phi_t, x);
}

void OctNode::coeffs_daub4(OrientedPoint &pt, int maxDepth, int depth, vect3f &mine, vect3f &ext, int minDepth)
{
	if (g.do_pts_node)
	{
		if (pts_node() == 0)
			return;
	}
	else
	{
		if (pt_num(0,0,0) + pt_num(0,0,1) + pt_num(0,1,0) + pt_num(0,1,1) +
			pt_num(1,0,0) + pt_num(1,0,1) + pt_num(1,1,0) + pt_num(1,1,1) == 0)
			return;
	}
	vect3f ext2 = ext*.5;
	vect3f center = mine + ext2;
	int ix = 0, iy = 0, iz = 0;

	if (pt.pos[0] > center[0])
		ix = 1;
	if (pt.pos[1] > center[1])
		iy = 1;
	if (pt.pos[2] > center[2])
		iz = 1;

	if (children(ix,iy,iz).data)
	{
		vect3f corner2(mine[0] + ext2[0]*ix, mine[1] + ext2[1]*iy, mine[2] + ext2[2]*iz);
		children(ix,iy,iz).coeffs_daub4(pt, maxDepth, depth+1, corner2, ext2, minDepth);
	}
	
	if (pt.ds == 0)
	{
		if (g.do_pts_node)
			pt.ds = 0.25 / ((float)pts_node() * (float)(1 << (depth << 1)));
		else
			pt.ds = 0.25 / ((float)pt_num(ix,iy,iz) * (float)(1 << (depth << 1)));
	}

	if (depth > minDepth && depth <= maxDepth)
	{
		vect3f lp; // local position
		for (int i = 0; i < 3; i++)
			lp[i] = (pt.pos[i] - mine[i]) / ext[i];
		float factor = (1 << (depth << 1))*pt.ds;
		bool do_zero = (depth == 2);
		float phiData [ 3 ] [ 3 ], int_phiData [ 3 ] [ 3 ], psiData [ 3 ] [ 3 ], int_psiData [ 3 ] [ 3 ];
		float phi [ 3 ], psi [ 3 ], int_psi [ 3 ], int_phi [ 3 ];
		if ( do_zero )
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi ( lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi ( lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi ( lp [ i ] - x ) * pt.norm [ i ] * factor;
					int_phiData [ i ] [ x + 1 ] = Daub4::int_phi ( lp [ i ] - x ) * pt.norm [ i ] * factor;
				}
			}
		}
		else
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi ( lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi ( lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi ( lp [ i ] - x ) * pt.norm [ i ] * factor;
					int_phiData [ i ] [ x + 1 ] = 0;
				}
			}
		}
		OctNode n [ 3 ];
		for (int x = -1; x <= 1; x++)
		{
			phi [ 0 ] = phiData [ 0 ] [ x + 1 ];
			psi [ 0 ] = psiData [ 0 ] [ x + 1 ];
			int_phi [ 0 ] = int_phiData [ 0 ] [ x + 1 ];
			int_psi [ 0 ] = int_psiData [ 0 ] [ x + 1 ];
			if (x)
				n [ 0 ] = neighbors(0, (x+1)>>1);
			else
				n[ 0 ] = *this;

			for (int y = -1; y <= 1; y++)
			{
				phi [ 1 ] = phiData [ 1 ] [ y + 1 ];
				psi [ 1 ] = psiData [ 1 ] [ y + 1 ];
				int_phi [ 1 ] = int_phiData [ 1 ] [ y + 1 ];
				int_psi [ 1 ] = int_psiData [ 1 ] [ y + 1 ];
				if (y)
					n [ 1 ] = n [ 0 ].neighbors(1, (y+1)>>1);
				else
					n [ 1 ] = n [ 0 ];

				for (int z = -1; z <= 1; z++)
				{
					phi [ 2 ] = phiData [ 2 ] [ z + 1 ];
					psi [ 2 ] = psiData [ 2 ] [ z + 1 ];
					int_phi [ 2 ] = int_phiData [ 2 ] [ z + 1 ];
					int_psi [ 2 ] = int_psiData [ 2 ] [ z + 1 ];
					if (z)
						n [ 2 ] = n [ 1 ].neighbors(2, (z+1)>>1);
					else
						n [ 2 ] = n [ 1 ];
					n[2].coeffs(0,0,0) += (int_phi[0]*phi[1]*phi[2] + int_phi[1]*phi[0]*phi[2] + int_phi[2]*phi[0]*phi[1]) * (1.0/3.0);

					n[2].coeffs(0,0,1) += ( phi[0]*phi[1]*int_psi[2] );
					n[2].coeffs(0,1,0) += ( phi[0]*int_psi[1]*phi[2] );
					n[2].coeffs(1,0,0) += ( int_psi[0]*phi[1]*phi[2] );

					n[2].coeffs(0,1,1) += ( int_psi[1]*psi[2] + psi[1]*int_psi[2] )*phi[0] * .5;
					n[2].coeffs(1,1,0) += ( psi[0]*int_psi[1] + int_psi[0]*psi[1] )*phi[2] * .5;
					n[2].coeffs(1,0,1) += ( psi[0]*int_psi[2] + int_psi[0]*psi[2] )*phi[1] * .5;

					n[2].coeffs(1,1,1) += ( psi[0]*(psi[1]*int_psi[2] + int_psi[1]*psi[2]) + int_psi[0]*psi[1]*psi[2] ) * (1.0/3.0);
				}
			}

		}
	}
}

void OctNode::coeffs_daub4ds(OrientedPoint &pt, int maxDepth, int depth, vect3f &mine, vect3f &ext, int minDepth)
{
	if (g.do_pts_node)
	{
		if (pts_node() == 0)
			return;
	}
	else
	{
		if (pt_num(0,0,0) + pt_num(0,0,1) + pt_num(0,1,0) + pt_num(0,1,1) +
			pt_num(1,0,0) + pt_num(1,0,1) + pt_num(1,1,0) + pt_num(1,1,1) == 0)
			return;
	}
	vect3f ext2 = ext*.5;
	vect3f center = mine + ext2;
	int ix = 0, iy = 0, iz = 0;

	if (pt.pos[0] > center[0])
		ix = 1;
	if (pt.pos[1] > center[1])
		iy = 1;
	if (pt.pos[2] > center[2])
		iz = 1;

	if (children(ix,iy,iz).data)
	{
		// not a leaf
		vect3f corner2(mine[0] + ext2[0]*ix, mine[1] + ext2[1]*iy, mine[2] + ext2[2]*iz);
		children(ix,iy,iz).coeffs_daub4(pt, maxDepth, depth+1, corner2, ext2, minDepth);
	}	
	if (pt.ds == 0)
	{
		if (g.do_pts_node)
			pt.ds = 0.25 / ((float)pts_node() * (float)(1 << (depth << 1)));
		else
			pt.ds = 0.25 / ((float)pt_num(ix,iy,iz) * (float)(1 << (depth << 1)));
	}

	if (depth > minDepth && depth <= maxDepth)
	{
		vect3f lp; // local position
		for (int i = 0; i < 3; i++)
			lp[i] = (pt.pos[i] - mine[i]) / ext[i];

		float factor = (1 << (depth << 1))*pt.ds;
		bool do_zero = (depth == 2);

		float phiData [ 3 ] [ 3 ], int_phiData [ 3 ] [ 3 ], psiData [ 3 ] [ 3 ], int_psiData [ 3 ] [ 3 ];
		float phi [ 3 ], psi [ 3 ], int_psi [ 3 ], int_phi [ 3 ];

		if ( do_zero )
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi ( lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi ( lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi ( lp [ i ] - x ) * pt.norm [ i ] * factor;
					int_phiData [ i ] [ x + 1 ] = Daub4::int_phi ( lp [ i ] - x ) * pt.norm [ i ] * factor ;
				}
			}
		}
		else
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi ( lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi ( lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi ( lp [ i ] - x ) * pt.norm [ i ] * factor;
					int_phiData [ i ] [ x + 1 ] = 0;
				}
			}
		}
		OctNode n [ 3 ];
		for (int x = -1; x <= 1; x++)
		{
			phi [ 0 ] = phiData [ 0 ] [ x + 1 ];
			psi [ 0 ] = psiData [ 0 ] [ x + 1 ];
			int_phi [ 0 ] = int_phiData [ 0 ] [ x + 1 ];
			int_psi [ 0 ] = int_psiData [ 0 ] [ x + 1 ];
			if (x)
				n [ 0 ] = neighbors(0, (x+1)>>1);
			else
				n[ 0 ] = *this;

			for (int y = -1; y <= 1; y++)
			{
				phi [ 1 ] = phiData [ 1 ] [ y + 1 ];
				psi [ 1 ] = psiData [ 1 ] [ y + 1 ];
				int_phi [ 1 ] = int_phiData [ 1 ] [ y + 1 ];
				int_psi [ 1 ] = int_psiData [ 1 ] [ y + 1 ];
				if (y)
					n [ 1 ] = n [ 0 ].neighbors(1, (y+1)>>1);
				
				else
					n [ 1 ] = n [ 0 ];

				for (int z = -1; z <= 1; z++)
				{
					phi [ 2 ] = phiData [ 2 ] [ z + 1 ];
					psi [ 2 ] = psiData [ 2 ] [ z + 1 ];
					int_phi [ 2 ] = int_phiData [ 2 ] [ z + 1 ];
					int_psi [ 2 ] = int_psiData [ 2 ] [ z + 1 ];
					if (z)
						n [ 2 ] = n [ 1 ].neighbors(2, (z+1)>>1);
						
					else
						n [ 2 ] = n [ 1 ];
					n[2].coeffs(0,0,0) += (int_phi[0]*phi[1]*phi[2] + int_phi[1]*phi[0]*phi[2] + int_phi[2]*phi[0]*phi[1]) * (1.0/3.0);

					n[2].coeffs(0,0,1) += ( phi[0]*phi[1]*int_psi[2] );
					n[2].coeffs(0,1,0) += ( phi[0]*int_psi[1]*phi[2] );
					n[2].coeffs(1,0,0) += ( int_psi[0]*phi[1]*phi[2] );

					n[2].coeffs(0,1,1) += ( int_psi[1]*psi[2] + psi[1]*int_psi[2] )*phi[0] * .5;
					n[2].coeffs(1,1,0) += ( psi[0]*int_psi[1] + int_psi[0]*psi[1] )*phi[2] * .5;
					n[2].coeffs(1,0,1) += ( psi[0]*int_psi[2] + int_psi[0]*psi[2] )*phi[1] * .5;

					n[2].coeffs(1,1,1) += ( psi[0]*(psi[1]*int_psi[2] + int_psi[1]*psi[2]) + int_psi[0]*psi[1]*psi[2] ) * (1.0/3.0);

				}
			}

		}
	}
}

void OctNode::coeffs_daub4_restart(OrientedPoint &pt, int maxDepth, int depth, vect3f &mine, vect3f &ext, int minDepth)
{
	if (g.do_pts_node)
	{
		if (pts_node() == 0)
			return;
	}
	else
	{
		if (pt_num(0,0,0) + pt_num(0,0,1) + pt_num(0,1,0) + pt_num(0,1,1) +
			pt_num(1,0,0) + pt_num(1,0,1) + pt_num(1,1,0) + pt_num(1,1,1) == 0)
			return;
	}

	// split the node and push down point
	vect3f ext2 = ext*.5;
	vect3f center = mine + ext2;

	int ix = 0, iy = 0, iz = 0;

	if (pt.pos[0] > center[0])
		ix = 1;
	if (pt.pos[1] > center[1])
		iy = 1;
	if (pt.pos[2] > center[2])
		iz = 1;

	// push down
	if (children(ix,iy,iz).data)
	{
		// not a leaf
		vect3f corner2(mine[0] + ext2[0]*ix, mine[1] + ext2[1]*iy, mine[2] + ext2[2]*iz);
		children(ix,iy,iz).coeffs_daub4_restart(pt, maxDepth, depth+1, corner2, ext2, minDepth);
	}

	
	if (pt.ds == 0)
	{
		if (g.do_pts_node)
			pt.ds = 0.25 / ((float)pts_node() * (float)(1 << (depth << 1)));
		else
			pt.ds = 0.25 / ((float)pt_num(ix,iy,iz) * (float)(1 << (depth << 1)));
	}

	if (depth > minDepth && depth <= maxDepth)
	{
		vect3f lp; // local position
		for (int i = 0; i < 3; i++)
			lp[i] = (pt.pos[i] - mine[i]) / ext[i];

		// add to coefficients
		float factor = (1 << (depth << 1))*pt.ds;
		bool do_zero = (depth == 2);
		float phiData [ 3 ] [ 3 ], int_phiData [ 3 ] [ 3 ], psiData [ 3 ] [ 3 ], int_psiData [ 3 ] [ 3 ];
		float phi [ 3 ], psi [ 3 ], int_psi [ 3 ], int_phi [ 3 ];

		if ( do_zero )
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi ( lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi ( lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi ( lp [ i ] - x ) * pt.norm [ i ] * factor;
					int_phiData [ i ] [ x + 1 ] = Daub4::int_phi ( lp [ i ] - x ) * pt.norm [ i ] * factor ;
				}
			}
		}
		else
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi ( lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi ( lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi ( lp [ i ] - x ) * pt.norm [ i ] * factor;
					int_phiData [ i ] [ x + 1 ] = 0;
				}
			}
		}
		OctNode n [ 3 ];
		for (int x = -1; x <= 1; x++)
		{
			phi [ 0 ] = phiData [ 0 ] [ x + 1 ];
			psi [ 0 ] = psiData [ 0 ] [ x + 1 ];
			int_phi [ 0 ] = int_phiData [ 0 ] [ x + 1 ];
			int_psi [ 0 ] = int_psiData [ 0 ] [ x + 1 ];
			if (x)
				n [ 0 ] = neighbors(0, (x+1)>>1);
			else
				n[ 0 ] = *this;

			for (int y = -1; y <= 1; y++)
			{
				phi [ 1 ] = phiData [ 1 ] [ y + 1 ];
				psi [ 1 ] = psiData [ 1 ] [ y + 1 ];
				int_phi [ 1 ] = int_phiData [ 1 ] [ y + 1 ];
				int_psi [ 1 ] = int_psiData [ 1 ] [ y + 1 ];
				if (y)
					n [ 1 ] = n [ 0 ].neighbors(1, (y+1)>>1);
				else
					n [ 1 ] = n [ 0 ];

				for (int z = -1; z <= 1; z++)
				{
					phi [ 2 ] = phiData [ 2 ] [ z + 1 ];
					psi [ 2 ] = psiData [ 2 ] [ z + 1 ];
					int_phi [ 2 ] = int_phiData [ 2 ] [ z + 1 ];
					int_psi [ 2 ] = int_psiData [ 2 ] [ z + 1 ];
					if (z)
						n [ 2 ] = n [ 1 ].neighbors(2, (z+1)>>1);
					else
						n [ 2 ] = n [ 1 ];
					n[2].coeffs(0,0,0) =0;

					n[2].coeffs(0,0,1) =0;
					n[2].coeffs(0,1,0) =0;
					n[2].coeffs(1,0,0) =0;

					n[2].coeffs(0,1,1) =0;
					n[2].coeffs(1,1,0) =0;
					n[2].coeffs(1,0,1) =0;

					n[2].coeffs(1,1,1) =0;
				}
			}

		}
	}
}
void OctNode::changecoeffs_daub4(OrientedPoint &pt, int maxDepth, int depth, vect3f &mine, vect3f &ext, int minDepth)
{
	if (g.do_pts_node)
	{
		if (pts_node() == 0)
			return;
	}
	else
	{
		if (pt_num(0,0,0) + pt_num(0,0,1) + pt_num(0,1,0) + pt_num(0,1,1) +
			pt_num(1,0,0) + pt_num(1,0,1) + pt_num(1,1,0) + pt_num(1,1,1) == 0)
			return;
	}

	vect3f ext2 = ext*.5;
	vect3f center = mine + ext2;
	int ix = 0, iy = 0, iz = 0;

	if (pt.pos[0] > center[0])
		ix = 1;
	if (pt.pos[1] > center[1])
		iy = 1;
	if (pt.pos[2] > center[2])
		iz = 1;

	// push down
	if (children(ix,iy,iz).data)
	{
		// not a leaf
		vect3f corner2(mine[0] + ext2[0]*ix, mine[1] + ext2[1]*iy, mine[2] + ext2[2]*iz);
		children(ix,iy,iz).coeffs_daub4(pt, maxDepth, depth+1, corner2, ext2, minDepth);
	}
	
	if (pt.ds == 0)
	{
		if (g.do_pts_node)
			pt.ds = 0.25 / ((float)pts_node() * (float)(1 << (depth << 1)));
		else
			pt.ds = 0.25 / ((float)pt_num(ix,iy,iz) * (float)(1 << (depth << 1)));
	}

	if (depth > minDepth && depth <= maxDepth)
	{
		vect3f lp; // local position
		for (int i = 0; i < 3; i++)
			lp[i] = (pt.pos[i] - mine[i]) / ext[i];

		// add to coefficients
		float factor = (1 << (depth << 1))*pt.ds;
		bool do_zero = (depth == 2);

		// Scott: evaluating functions incrementally yields 4X improvement in speed
		float phiData [ 3 ] [ 3 ], int_phiData [ 3 ] [ 3 ], psiData [ 3 ] [ 3 ], int_psiData [ 3 ] [ 3 ];
		float phi [ 3 ], psi [ 3 ], int_psi [ 3 ], int_phi [ 3 ];

		if ( do_zero )
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi ( lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi ( lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi ( lp [ i ] - x ) * pt.norm [ i ] * factor*(-2);
					int_phiData [ i ] [ x + 1 ] = Daub4::int_phi ( lp [ i ] - x ) * pt.norm [ i ] * factor*(-2);
				}
			}
		}
		else
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi ( lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi ( lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi ( lp [ i ] - x ) * pt.norm [ i ] * factor*(-2);
					int_phiData [ i ] [ x + 1 ] = 0;
				}
			}
		}
		OctNode n [ 3 ];
		for (int x = -1; x <= 1; x++)
		{
			phi [ 0 ] = phiData [ 0 ] [ x + 1 ];
			psi [ 0 ] = psiData [ 0 ] [ x + 1 ];
			int_phi [ 0 ] = int_phiData [ 0 ] [ x + 1 ];
			int_psi [ 0 ] = int_psiData [ 0 ] [ x + 1 ];
			if (x)
				n [ 0 ] = neighbors(0, (x+1)>>1);
			else
				n[ 0 ] = *this;

			for (int y = -1; y <= 1; y++)
			{
				phi [ 1 ] = phiData [ 1 ] [ y + 1 ];
				psi [ 1 ] = psiData [ 1 ] [ y + 1 ];
				int_phi [ 1 ] = int_phiData [ 1 ] [ y + 1 ];
				int_psi [ 1 ] = int_psiData [ 1 ] [ y + 1 ];

				if (y)
					n [ 1 ] = n [ 0 ].neighbors(1, (y+1)>>1);
				else
					n [ 1 ] = n [ 0 ];

				for (int z = -1; z <= 1; z++)
				{
					phi [ 2 ] = phiData [ 2 ] [ z + 1 ];
					psi [ 2 ] = psiData [ 2 ] [ z + 1 ];
					int_phi [ 2 ] = int_phiData [ 2 ] [ z + 1 ];
					int_psi [ 2 ] = int_psiData [ 2 ] [ z + 1 ];
					if (z)
						n [ 2 ] = n [ 1 ].neighbors(2, (z+1)>>1);
					else
						n [ 2 ] = n [ 1 ];

					n[2].coeffs(0,0,0) += (int_phi[0]*phi[1]*phi[2] + int_phi[1]*phi[0]*phi[2] + int_phi[2]*phi[0]*phi[1]) * (1.0/3.0);

					n[2].coeffs(0,0,1) += ( phi[0]*phi[1]*int_psi[2] );
					n[2].coeffs(0,1,0) += ( phi[0]*int_psi[1]*phi[2] );
					n[2].coeffs(1,0,0) += ( int_psi[0]*phi[1]*phi[2] );

					n[2].coeffs(0,1,1) += ( int_psi[1]*psi[2] + psi[1]*int_psi[2] )*phi[0] * .5;
					n[2].coeffs(1,1,0) += ( psi[0]*int_psi[1] + int_psi[0]*psi[1] )*phi[2] * .5;
					n[2].coeffs(1,0,1) += ( psi[0]*int_psi[2] + int_psi[0]*psi[2] )*phi[1] * .5;

					n[2].coeffs(1,1,1) += ( psi[0]*(psi[1]*int_psi[2] + int_psi[1]*psi[2]) + int_psi[0]*psi[1]*psi[2] ) * (1.0/3.0);
				}
			}

		}
	}
}
void OctNode::getValueAtPointdaub4(vect3f &pos,int maxDepth, int depth, vect3f &mine, vect3f &ext, int minDepth,float &val)
{
	if (g.do_pts_node)
	{
		if (pts_node() == 0)
			return;
	}
	else
	{
		if (pt_num(0,0,0) + pt_num(0,0,1) + pt_num(0,1,0) + pt_num(0,1,1) +
			pt_num(1,0,0) + pt_num(1,0,1) + pt_num(1,1,0) + pt_num(1,1,1) == 0)
			return;
	}
	vect3f ext2 = ext*.5;
	vect3f center = mine + ext2;

	int ix = 0, iy = 0, iz = 0;

	if (pos[0] > center[0])
		ix = 1;
	if (pos[1] > center[1])
		iy = 1;
	if (pos[2] > center[2])
		iz = 1;

	if (children(ix,iy,iz).data)
	{
		vect3f corner2(mine[0] + ext2[0]*ix, mine[1] + ext2[1]*iy, mine[2] + ext2[2]*iz);
		children(ix,iy,iz).getValueAtPointdaub4(pos, maxDepth, depth+1, corner2, ext2, minDepth,val);
	}

	if (depth > minDepth && depth <= maxDepth)
	{
		vect3f lp; // local position
		for (int i = 0; i < 3; i++)
			lp[i] = (pos[i] - mine[i]) / ext[i];

		bool do_zero = (depth == 2);

		float phiData [ 3 ] [ 3 ], int_phiData [ 3 ] [ 3 ], psiData [ 3 ] [ 3 ], int_psiData [ 3 ] [ 3 ];
		float phi [ 3 ], psi [ 3 ], int_psi [ 3 ], int_phi [ 3 ];

		float factor=0.0;

		if ( do_zero )
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi ( lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi ( lp [ i ] - x );
					factor=1;
				}
			}
		}
		else
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi ( lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi ( lp [ i ] - x );
					factor=0;
				}
			}
		}
		OctNode n [ 3 ];
		for (int x = -1; x <= 1; x++)
		{
			phi [ 0 ] = phiData [ 0 ] [ x + 1 ];
			psi [ 0 ] = psiData [ 0 ] [ x + 1 ];
			if (x)
				n [ 0 ] = neighbors(0, (x+1)>>1);
			else
				n[ 0 ] = *this;

			for (int y = -1; y <= 1; y++)
			{
				phi [ 1 ] = phiData [ 1 ] [ y + 1 ];
				psi [ 1 ] = psiData [ 1 ] [ y + 1 ];

				if (y)
					n [ 1 ] = n [ 0 ].neighbors(1, (y+1)>>1);
				else
					n [ 1 ] = n [ 0 ];

				for (int z = -1; z <= 1; z++)
				{
					phi [ 2 ] = phiData [ 2 ] [ z + 1 ];
					psi [ 2 ] = psiData [ 2 ] [ z + 1 ];
					if (z)
						n [ 2 ] = n [ 1 ].neighbors(2, (z+1)>>1);
					else
						n [ 2 ] = n [ 1 ];
					if (n[2].data)
					{
					val=val+n[2].coeffs(0,0,0)*(phi[0]*phi[1]*phi[2])*factor;
	
					val=val+n[2].coeffs(0,0,1)*( phi[0]*phi[1]*psi[2] );
					val=val+n[2].coeffs(0,1,0)*( phi[0]*psi[1]*phi[2] );
					val=val+n[2].coeffs(1,0,0)*( psi[0]*phi[1]*phi[2] );

					val=val+n[2].coeffs(0,1,1)*phi[0]*psi[1]*psi[2];
					val=val+n[2].coeffs(1,1,0)*psi[0]*psi[1]*phi[2];
					val=val+n[2].coeffs(1,0,1)*psi[0]*phi[1]*psi[2];

					val=val+n[2].coeffs(1,1,1)*psi[0]*psi[1]*psi[2];
					
					}

				}
			}

		}
	}
}

void readtable()
{
	string file_path01="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/phi0.txt";
    ifstream infile;
    infile.open(file_path01);

    if(!infile)
    {
        printf("error! unable to open %s", file_path01.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&phi_s0[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&phi_s0[i]);
			i++;
        }
    }
    infile.close();

	string file_path02="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/psi0.txt";
    infile.open(file_path02);
    if (!infile)
    {
        printf("error! unable to open %s", file_path02.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&psi_s0[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&psi_s0[i]);
			i++;
        }
    }
    infile.close();
	string file_path03="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intphi0.txt";
    infile.open(file_path03);
    if (!infile)
    {
        printf("error! unable to open %s", file_path03.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_phi_s0[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_phi_s0[i]);
			i++;
        }
    }
    infile.close();
	string file_path04="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intpsi0.txt";
    infile.open(file_path04);
    if (!infile)
    {
        printf("error! unable to open %s", file_path04.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_psi_s0[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_psi_s0[i]);
			i++;
        }
    }
    infile.close();
	string file_path11="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/phi1.txt";
    infile.open(file_path11);

    if(!infile)
    {
        printf("error! unable to open %s", file_path11.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&phi_s1[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&phi_s1[i]);
			i++;
        }
    }
    infile.close();

	string file_path12="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/psi1.txt";
    infile.open(file_path12);
    if (!infile)
    {
        printf("error! unable to open %s", file_path12.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&psi_s1[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&psi_s1[i]);
			i++;
        }
    }
    infile.close();
	string file_path13="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intphi1.txt";
    infile.open(file_path13);
    if (!infile)
    {
        printf("error! unable to open %s", file_path13.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_phi_s1[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_phi_s1[i]);
			i++;
        }
    }
    infile.close();
	string file_path14="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intpsi1.txt";
    infile.open(file_path14);
    if (!infile)
    {
        printf("error! unable to open %s", file_path14.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_psi_s1[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_psi_s1[i]);
			i++;
        }
    }
    infile.close();
	string file_path21="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/phi2.txt";
    infile.open(file_path21);

    if(!infile)
    {
        printf("error! unable to open %s", file_path21.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&phi_s2[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&phi_s2[i]);
			i++;
        }
    }
    infile.close();

	string file_path22="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/psi2.txt";
    infile.open(file_path22);
    if (!infile)
    {
        printf("error! unable to open %s", file_path22.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&psi_s0[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&psi_s0[i]);
			i++;
        }
    }
    infile.close();
	string file_path23="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intphi2.txt";
    infile.open(file_path23);
    if (!infile)
    {
        printf("error! unable to open %s", file_path23.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_phi_s2[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_phi_s2[i]);
			i++;
        }
    }
    infile.close();
	string file_path24="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intpsi2.txt";
    infile.open(file_path24);
    if (!infile)
    {
        printf("error! unable to open %s", file_path24.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_psi_s2[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_psi_s2[i]);
			i++;
        }
    }
    infile.close();
	string file_path31="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/phi3.txt";
    infile.open(file_path31);

    if(!infile)
    {
        printf("error! unable to open %s", file_path31.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&phi_s3[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&phi_s3[i]);
			i++;
        }
    }
    infile.close();

	string file_path32="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/psi3.txt";
    infile.open(file_path32);
    if (!infile)
    {
        printf("error! unable to open %s", file_path32.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&psi_s3[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&psi_s3[i]);
			i++;
        }
    }
    infile.close();
	string file_path33="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intphi3.txt";
    infile.open(file_path33);
    if (!infile)
    {
        printf("error! unable to open %s", file_path33.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_phi_s3[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_phi_s3[i]);
			i++;
        }
    }
    infile.close();
	string file_path34="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intpsi3.txt";
    infile.open(file_path34);
    if (!infile)
    {
        printf("error! unable to open %s", file_path34.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_psi_s3[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_psi_s3[i]);
			i++;
        }
    }
    infile.close();
	string file_path41="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/phi4.txt";
    infile.open(file_path41);

    if(!infile)
    {
        printf("error! unable to open %s", file_path41.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&phi_s4[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&phi_s4[i]);
			i++;
        }
    }
    infile.close();

	string file_path42="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/psi4.txt";
    infile.open(file_path42);
    if (!infile)
    {
        printf("error! unable to open %s", file_path42.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&psi_s4[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&psi_s4[i]);
			i++;
        }
    }
    infile.close();
	string file_path43="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intphi4.txt";
    infile.open(file_path43);
    if (!infile)
    {
        printf("error! unable to open %s", file_path43.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_phi_s4[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_phi_s4[i]);
			i++;
        }
    }
    infile.close();
	string file_path44="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intpsi4.txt";
    infile.open(file_path44);
    if (!infile)
    {
        printf("error! unable to open %s", file_path44.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_psi_s4[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_psi_s4[i]);
			i++;
        }
    }
    infile.close();
	string file_path51="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/phi5.txt";
    infile.open(file_path51);

    if(!infile)
    {
        printf("error! unable to open %s", file_path51.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&phi_s5[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&phi_s5[i]);
			i++;
        }
    }
    infile.close();

	string file_path52="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/psi5.txt";
    infile.open(file_path52);
    if (!infile)
    {
        printf("error! unable to open %s", file_path52.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&psi_s5[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&psi_s5[i]);
			i++;
        }
    }
    infile.close();
	string file_path53="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intphi5.txt";
    infile.open(file_path53);
    if (!infile)
    {
        printf("error! unable to open %s", file_path53.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_phi_s5[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_phi_s5[i]);
			i++;
        }
    }
    infile.close();
	string file_path54="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intpsi5.txt";
    infile.open(file_path54);
    if (!infile)
    {
        printf("error! unable to open %s", file_path54.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_psi_s5[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_psi_s5[i]);
			i++;
        }
    }
    infile.close();
	string file_path61="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/phi6.txt";
    infile.open(file_path61);

    if(!infile)
    {
        printf("error! unable to open %s", file_path61.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&phi_s6[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&phi_s6[i]);
			i++;
        }
    }
    infile.close();

	string file_path62="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/psi6.txt";
    infile.open(file_path62);
    if (!infile)
    {
        printf("error! unable to open %s", file_path62.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&psi_s6[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&psi_s6[i]);
			i++;
        }
    }
    infile.close();
	string file_path63="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intphi6.txt";
    infile.open(file_path63);
    if (!infile)
    {
        printf("error! unable to open %s", file_path63.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_phi_s6[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_phi_s6[i]);
			i++;
        }
    }
    infile.close();
	string file_path64="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intpsi6.txt";
    infile.open(file_path64);
    if (!infile)
    {
        printf("error! unable to open %s", file_path64.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_psi_s6[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_psi_s6[i]);
			i++;
        }
    }
    infile.close();
	string file_path71="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/phi7.txt";
    infile.open(file_path71);

    if(!infile)
    {
        printf("error! unable to open %s", file_path71.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&phi_s7[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&phi_s7[i]);
			i++;
        }
    }
    infile.close();

	string file_path72="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/psi7.txt";
    infile.open(file_path72);
    if (!infile)
    {
        printf("error! unable to open %s", file_path72.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&psi_s7[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&psi_s7[i]);
			i++;
        }
    }
    infile.close();
	string file_path73="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intphi7.txt";
    infile.open(file_path73);
    if (!infile)
    {
        printf("error! unable to open %s", file_path73.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_phi_s7[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_phi_s7[i]);
			i++;
        }
    }
    infile.close();
	string file_path74="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intpsi7.txt";
    infile.open(file_path74);
    if (!infile)
    {
        printf("error! unable to open %s", file_path74.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_psi_s7[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_psi_s7[i]);
			i++;
        }
    }
    infile.close();
	string file_path81="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/phi8.txt";
    infile.open(file_path81);

    if(!infile)
    {
        printf("error! unable to open %s", file_path81.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&phi_s8[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&phi_s8[i]);
			i++;
        }
    }
    infile.close();

	string file_path82="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/psi8.txt";
    infile.open(file_path82);
    if (!infile)
    {
        printf("error! unable to open %s", file_path82.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&psi_s8[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&psi_s8[i]);
			i++;
        }
    }
    infile.close();
	string file_path83="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intphi8.txt";
    infile.open(file_path83);
    if (!infile)
    {
        printf("error! unable to open %s", file_path83.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_phi_s8[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_phi_s8[i]);
			i++;
        }
    }
    infile.close();
	string file_path84="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intpsi8.txt";
    infile.open(file_path84);
    if (!infile)
    {
        printf("error! unable to open %s", file_path84.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_psi_s8[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_psi_s8[i]);
			i++;
        }
    }
    infile.close();
	string file_path91="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/phi9.txt";
    infile.open(file_path91);

    if(!infile)
    {
        printf("error! unable to open %s", file_path91.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&phi_s9[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&phi_s9[i]);
			i++;
        }
    }
    infile.close();

	string file_path92="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/psi9.txt";
    infile.open(file_path92);
    if (!infile)
    {
        printf("error! unable to open %s", file_path92.c_str());
        return;
    }
    else
    {
        string line;
        getline(infile, line);
        sscanf(line.c_str(), "%f",&psi_s9[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&psi_s9[i]);
			i++;
        }
    }
    infile.close();
	string file_path93="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intphi9.txt";
    infile.open(file_path93);
    if (!infile)
    {
        printf("error! unable to open %s", file_path93.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_phi_s9[0]);
		int i=1;
        while (getline(infile, line))
        {
            sscanf(line.c_str(), "%f",&int_phi_s9[i]);
			i++;
        }
    }
    infile.close();
	string file_path94="D:/Surface_Reconstruction/WaveletPipeRecon_Linux64/soomthloadhaar/intpsi9.txt";
    infile.open(file_path94);
    if (!infile)
    {
        printf("error! unable to open %s", file_path94.c_str());
        return;
    }
    else
    {
        string line;

        getline(infile, line);
        sscanf(line.c_str(), "%f",&int_psi_s9[0]);
		int i=1;
        while (getline(infile, line))  
        {
            sscanf(line.c_str(), "%f",&int_psi_s9[i]);
			i++;
        }
    }
    infile.close();
}
void OctNode::coeffs_haar_smooth(OrientedPoint &pt, int maxDepth, int depth, vect3f &mine, vect3f &ext, int minDepth)
{
	if (g.do_pts_node)
	{
		if (pts_node() == 0)
			return;
	}
	else
	{
		if (pt_num(0,0,0) + pt_num(0,0,1) + pt_num(0,1,0) + pt_num(0,1,1) +
			pt_num(1,0,0) + pt_num(1,0,1) + pt_num(1,1,0) + pt_num(1,1,1) == 0)
			return;
	}


	vect3f ext2 = ext*.5;
	vect3f center = mine + ext2;

	int ix = 0, iy = 0, iz = 0;

	if (pt.pos[0] > center[0])
		ix = 1;
	if (pt.pos[1] > center[1])
		iy = 1;
	if (pt.pos[2] > center[2])
		iz = 1;

	if (children(ix,iy,iz).data)
	{
		// not a leaf
		vect3f corner2(mine[0] + ext2[0]*ix, mine[1] + ext2[1]*iy, mine[2] + ext2[2]*iz);
		children(ix,iy,iz).coeffs_haar_smooth(pt, maxDepth, depth+1, corner2, ext2, minDepth);
	}
	
	if (pt.ds == 0)
	{
		if (g.do_pts_node)
			pt.ds = 0.25 / ((float)pts_node() * (float)(1 << (depth << 1)));
		else
			pt.ds = 0.25 / ((float)pt_num(ix,iy,iz) * (float)(1 << (depth << 1)));
	}

	if (depth > minDepth && depth <= maxDepth)
	{
		vect3f lp; // local position
		for (int i = 0; i < 3; i++)
			lp[i] = (pt.pos[i] - mine[i]) / ext[i];

		// add to coefficients
		float factor = (1 << (depth << 1))*pt.ds;
		bool do_zero = (depth == 2);
		float phiData [ 3 ] [ 3 ], int_phiData [ 3 ] [ 3 ], psiData [ 3 ] [ 3 ], int_psiData [ 3 ] [ 3 ];
		float phi [ 3 ], psi [ 3 ], int_psi [ 3 ], int_phi [ 3 ];

		if ( do_zero )
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi_smooth (depth,lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi_smooth ( depth,lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi_smooth (depth, lp [ i ] - x ) * pt.norm [ i ] * factor;
					int_phiData [ i ] [ x + 1 ] = Daub4::int_phi_smooth (depth, lp [ i ] - x ) * pt.norm [ i ] * factor;
				}
			}
		}
		else
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi_smooth (depth, lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi_smooth ( depth,lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi_smooth ( depth,lp [ i ] - x ) * pt.norm [ i ] * factor;
					int_phiData [ i ] [ x + 1 ] = 0;
				}
			}
		}
		OctNode n [ 3 ];
		for (int x = -1; x <= 1; x++)
		{
			phi [ 0 ] = phiData [ 0 ] [ x + 1 ];
			psi [ 0 ] = psiData [ 0 ] [ x + 1 ];
			int_phi [ 0 ] = int_phiData [ 0 ] [ x + 1 ];
			int_psi [ 0 ] = int_psiData [ 0 ] [ x + 1 ];
			if (x)
				n [ 0 ] = neighbors(0, (x+1)>>1);
			else
				n[ 0 ] = *this;

			for (int y = -1; y <= 1; y++)
			{
				phi [ 1 ] = phiData [ 1 ] [ y + 1 ];
				psi [ 1 ] = psiData [ 1 ] [ y + 1 ];
				int_phi [ 1 ] = int_phiData [ 1 ] [ y + 1 ];
				int_psi [ 1 ] = int_psiData [ 1 ] [ y + 1 ];
				if (y)
					n [ 1 ] = n [ 0 ].neighbors(1, (y+1)>>1);
				else
					n [ 1 ] = n [ 0 ];

				for (int z = -1; z <= 1; z++)
				{
					phi [ 2 ] = phiData [ 2 ] [ z + 1 ];
					psi [ 2 ] = psiData [ 2 ] [ z + 1 ];
					int_phi [ 2 ] = int_phiData [ 2 ] [ z + 1 ];
					int_psi [ 2 ] = int_psiData [ 2 ] [ z + 1 ];
					if (z)
						n [ 2 ] = n [ 1 ].neighbors(2, (z+1)>>1);
					else
						n [ 2 ] = n [ 1 ];
					n[2].coeffs(0,0,0) += (int_phi[0]*phi[1]*phi[2] + int_phi[1]*phi[0]*phi[2] + int_phi[2]*phi[0]*phi[1]) * (1.0/3.0);

					n[2].coeffs(0,0,1) += ( phi[0]*phi[1]*int_psi[2] );
					n[2].coeffs(0,1,0) += ( phi[0]*int_psi[1]*phi[2] );
					n[2].coeffs(1,0,0) += ( int_psi[0]*phi[1]*phi[2] );

					n[2].coeffs(0,1,1) += ( int_psi[1]*psi[2] + psi[1]*int_psi[2] )*phi[0] * .5;
					n[2].coeffs(1,1,0) += ( psi[0]*int_psi[1] + int_psi[0]*psi[1] )*phi[2] * .5;
					n[2].coeffs(1,0,1) += ( psi[0]*int_psi[2] + int_psi[0]*psi[2] )*phi[1] * .5;

					n[2].coeffs(1,1,1) += ( psi[0]*(psi[1]*int_psi[2] + int_psi[1]*psi[2]) + int_psi[0]*psi[1]*psi[2] ) * (1.0/3.0);
				}
			}

		}
	}
}

void OctNode::changecoeffs_haar_smooth(OrientedPoint &pt, int maxDepth, int depth, vect3f &mine, vect3f &ext, int minDepth)
{
	if (g.do_pts_node)
	{
		if (pts_node() == 0)
			return;
	}
	else
	{
		if (pt_num(0,0,0) + pt_num(0,0,1) + pt_num(0,1,0) + pt_num(0,1,1) +
			pt_num(1,0,0) + pt_num(1,0,1) + pt_num(1,1,0) + pt_num(1,1,1) == 0)
			return;
	}

	// split the node and push down point
	vect3f ext2 = ext*.5;
	vect3f center = mine + ext2;

	int ix = 0, iy = 0, iz = 0;

	if (pt.pos[0] > center[0])
		ix = 1;
	if (pt.pos[1] > center[1])
		iy = 1;
	if (pt.pos[2] > center[2])
		iz = 1;

	// push down
	if (children(ix,iy,iz).data)
	{
		// not a leaf
		vect3f corner2(mine[0] + ext2[0]*ix, mine[1] + ext2[1]*iy, mine[2] + ext2[2]*iz);
		children(ix,iy,iz).coeffs_daub4(pt, maxDepth, depth+1, corner2, ext2, minDepth);
	}
	
	if (pt.ds == 0)
	{
		if (g.do_pts_node)
			pt.ds = 0.25 / ((float)pts_node() * (float)(1 << (depth << 1)));
		else
			pt.ds = 0.25 / ((float)pt_num(ix,iy,iz) * (float)(1 << (depth << 1)));
	}

	if (depth > minDepth && depth <= maxDepth)
	{

		vect3f lp; // local position
		for (int i = 0; i < 3; i++)
			lp[i] = (pt.pos[i] - mine[i]) / ext[i];

		// add to coefficients
		float factor = (1 << (depth << 1))*pt.ds;
		bool do_zero = (depth == 2);

		// Scott: evaluating functions incrementally yields 4X improvement in speed
		float phiData [ 3 ] [ 3 ], int_phiData [ 3 ] [ 3 ], psiData [ 3 ] [ 3 ], int_psiData [ 3 ] [ 3 ];
		float phi [ 3 ], psi [ 3 ], int_psi [ 3 ], int_phi [ 3 ];


		if ( do_zero )
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi_smooth (depth, lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi_smooth ( depth,lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi_smooth ( depth,lp [ i ] - x ) * pt.norm [ i ] * factor;
					// int_phiData [ i ] [ x + 1 ] = Daub4::int_phi ( lp [ i ] - x ) * pt.norm [ i ] * factor * (1.0/3.0);
					int_phiData [ i ] [ x + 1 ] = Daub4::int_phi_smooth ( depth,lp [ i ] - x ) * pt.norm [ i ] * factor;
				}
			}
		}
		else
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi_smooth ( depth,lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi_smooth ( depth,lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi_smooth ( depth,lp [ i ] - x ) * pt.norm [ i ] * factor;
					int_phiData [ i ] [ x + 1 ] = 0;
				}
			}
		}
		OctNode n [ 3 ];
		for (int x = -1; x <= 1; x++)
		{
			phi [ 0 ] = phiData [ 0 ] [ x + 1 ];
			psi [ 0 ] = psiData [ 0 ] [ x + 1 ];
			int_phi [ 0 ] = int_phiData [ 0 ] [ x + 1 ];
			int_psi [ 0 ] = int_psiData [ 0 ] [ x + 1 ];
			//total_int_phi [ 0 ] = int_phiData [ 0 ] [ x + 1 ];
			if (x)
				n [ 0 ] = neighbors(0, (x+1)>>1);
			else
				n[ 0 ] = *this;

			for (int y = -1; y <= 1; y++)
			{
				phi [ 1 ] = phiData [ 1 ] [ y + 1 ];
				psi [ 1 ] = psiData [ 1 ] [ y + 1 ];
				int_phi [ 1 ] = int_phiData [ 1 ] [ y + 1 ];
				int_psi [ 1 ] = int_psiData [ 1 ] [ y + 1 ];
				//total_int_phi [ 1 ] = total_int_phi [ 0 ] + int_phiData [ 1 ] [ y + 1 ];
				if (y)
					n [ 1 ] = n [ 0 ].neighbors(1, (y+1)>>1);
					// 0或1
				else
					n [ 1 ] = n [ 0 ];

				for (int z = -1; z <= 1; z++)
				{
					phi [ 2 ] = phiData [ 2 ] [ z + 1 ];
					psi [ 2 ] = psiData [ 2 ] [ z + 1 ];
					int_phi [ 2 ] = int_phiData [ 2 ] [ z + 1 ];
					int_psi [ 2 ] = int_psiData [ 2 ] [ z + 1 ];
					//total_int_phi [ 2 ] = total_int_phi [ 1 ] + int_phiData [ 2 ] [ z + 1 ];
					if (z)
						n [ 2 ] = n [ 1 ].neighbors(2, (z+1)>>1);
					else
						n [ 2 ] = n [ 1 ];

					n[2].coeffs(0,0,0) += (-2)*(int_phi[0]*phi[1]*phi[2] + int_phi[1]*phi[0]*phi[2] + int_phi[2]*phi[0]*phi[1]) * (1.0/3.0);

					n[2].coeffs(0,0,1) += (-2)*( phi[0]*phi[1]*int_psi[2] );
					n[2].coeffs(0,1,0) += (-2)*( phi[0]*int_psi[1]*phi[2] );
					n[2].coeffs(1,0,0) += (-2)*( int_psi[0]*phi[1]*phi[2] );

					n[2].coeffs(0,1,1) += (-2)*( int_psi[1]*psi[2] + psi[1]*int_psi[2] )*phi[0] * .5;
					n[2].coeffs(1,1,0) += (-2)*( psi[0]*int_psi[1] + int_psi[0]*psi[1] )*phi[2] * .5;
					n[2].coeffs(1,0,1) += (-2)*( psi[0]*int_psi[2] + int_psi[0]*psi[2] )*phi[1] * .5;

					n[2].coeffs(1,1,1) += (-2)*( psi[0]*(psi[1]*int_psi[2] + int_psi[1]*psi[2]) + int_psi[0]*psi[1]*psi[2] ) * (1.0/3.0);
				}
			}

		}
	}
}
void OctNode::coeffs_haar_smooth_restart(OrientedPoint &pt, int maxDepth, int depth, vect3f &mine, vect3f &ext, int minDepth)
{
	if (g.do_pts_node)
	{
		if (pts_node() == 0)
			return;
	}
	else
	{
		if (pt_num(0,0,0) + pt_num(0,0,1) + pt_num(0,1,0) + pt_num(0,1,1) +
			pt_num(1,0,0) + pt_num(1,0,1) + pt_num(1,1,0) + pt_num(1,1,1) == 0)
			return;
	}

	// split the node and push down point
	vect3f ext2 = ext*.5;
	vect3f center = mine + ext2;

	int ix = 0, iy = 0, iz = 0;

	if (pt.pos[0] > center[0])
		ix = 1;
	if (pt.pos[1] > center[1])
		iy = 1;
	if (pt.pos[2] > center[2])
		iz = 1;

	// push down
	if (children(ix,iy,iz).data)
	{
		// not a leaf
		vect3f corner2(mine[0] + ext2[0]*ix, mine[1] + ext2[1]*iy, mine[2] + ext2[2]*iz);
		children(ix,iy,iz).coeffs_daub4_restart(pt, maxDepth, depth+1, corner2, ext2, minDepth);
	}

	
	if (pt.ds == 0)
	{
		if (g.do_pts_node)
			pt.ds = 0.25 / ((float)pts_node() * (float)(1 << (depth << 1)));
		else
			pt.ds = 0.25 / ((float)pt_num(ix,iy,iz) * (float)(1 << (depth << 1)));
	}

	if (depth > minDepth && depth <= maxDepth)
	{

		vect3f lp; // local position
		for (int i = 0; i < 3; i++)
			lp[i] = (pt.pos[i] - mine[i]) / ext[i];

		// add to coefficients
		float factor = (1 << (depth << 1))*pt.ds;
		bool do_zero = (depth == 2);

		// Scott: evaluating functions incrementally yields 4X improvement in speed
		float phiData [ 3 ] [ 3 ], int_phiData [ 3 ] [ 3 ], psiData [ 3 ] [ 3 ], int_psiData [ 3 ] [ 3 ];
		float phi [ 3 ], psi [ 3 ], int_psi [ 3 ], int_phi [ 3 ];
		if ( do_zero )
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi_smooth ( depth,lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi_smooth ( depth,lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi_smooth ( depth,lp [ i ] - x ) * pt.norm [ i ] * factor;
					// int_phiData [ i ] [ x + 1 ] = Daub4::int_phi ( lp [ i ] - x ) * pt.norm [ i ] * factor * (1.0/3.0);
					int_phiData [ i ] [ x + 1 ] = Daub4::int_phi_smooth ( depth,lp [ i ] - x ) * pt.norm [ i ] * factor ;
				}
			}
		}
		else
		{
			for ( int i = 0; i < 3; i++ )
			{
				for ( int x = -1; x <= 1; x++ )
				{
					phiData [ i ] [ x + 1 ] = Daub4::phi_smooth ( depth,lp [ i ] - x );
					psiData [ i ] [ x + 1 ] = Daub4::psi_smooth ( depth,lp [ i ] - x );
					int_psiData [ i ] [ x + 1 ] = Daub4::int_psi_smooth ( depth,lp [ i ] - x ) * pt.norm [ i ] * factor;
					int_phiData [ i ] [ x + 1 ] = 0;
				}
			}
		}
		OctNode n [ 3 ];
		for (int x = -1; x <= 1; x++)
		{
			phi [ 0 ] = phiData [ 0 ] [ x + 1 ];
			psi [ 0 ] = psiData [ 0 ] [ x + 1 ];
			int_phi [ 0 ] = int_phiData [ 0 ] [ x + 1 ];
			int_psi [ 0 ] = int_psiData [ 0 ] [ x + 1 ];
			if (x)
				n [ 0 ] = neighbors(0, (x+1)>>1);
			else
				n[ 0 ] = *this;

			for (int y = -1; y <= 1; y++)
			{
				phi [ 1 ] = phiData [ 1 ] [ y + 1 ];
				psi [ 1 ] = psiData [ 1 ] [ y + 1 ];
				int_phi [ 1 ] = int_phiData [ 1 ] [ y + 1 ];
				int_psi [ 1 ] = int_psiData [ 1 ] [ y + 1 ];
				if (y)
					n [ 1 ] = n [ 0 ].neighbors(1, (y+1)>>1);
					// 0或1
				else
					n [ 1 ] = n [ 0 ];

				for (int z = -1; z <= 1; z++)
				{
					phi [ 2 ] = phiData [ 2 ] [ z + 1 ];
					psi [ 2 ] = psiData [ 2 ] [ z + 1 ];
					int_phi [ 2 ] = int_phiData [ 2 ] [ z + 1 ];
					int_psi [ 2 ] = int_psiData [ 2 ] [ z + 1 ];
					if (z)
						n [ 2 ] = n [ 1 ].neighbors(2, (z+1)>>1);
					else
						n [ 2 ] = n [ 1 ];
					n[2].coeffs(0,0,0) =0;

					n[2].coeffs(0,0,1) =0;
					n[2].coeffs(0,1,0) =0;
					n[2].coeffs(1,0,0) =0;

					n[2].coeffs(0,1,1) =0;
					n[2].coeffs(1,1,0) =0;
					n[2].coeffs(1,0,1) =0;

					n[2].coeffs(1,1,1) =0;
				}
			}

		}
	}
}
